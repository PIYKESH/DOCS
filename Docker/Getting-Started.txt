Docker 
1- Docker is a advanced version of virtualization in form of Containerization.
2- Hypervisor is used for virtualization but in case of Containerization we use Docker Engine.
3- Docker provides all the dependencies in an environment which prevents conflicts for code version or it can be anything. 
4- Docker uses Container on the host O.S to run the applications to use the same Linux kernel as system on the host computer, rather than creating new a whole new virtual O.S.
5- We can install in any O.S but docker engine runs natively on Linux Distribution. 
6- Docker was first released in march 2013 by Soloman Hykes and Sebastian Pahl, Which is written in GO language.
7- Docker is a set of platform as a service that uses O.S level virtualization where VM ware uses Hardware level Virtualization.
8- Disadvantages:- a) Docker is not a good solution for application that requires rich GUI.
				   b) Docker does not provide cross-platform compatibility if an application is designed to run in docker.
				   c) Docker is suitable when Dev O.S and OPS O.S are same, If the O.S is different then we should use VM.


Microservices Architecture-A variant of the service-oriented architecture (SOA) structural style- arranges an application as a collection of loosely coupled services. In a microservices arch, , services are fine grained and the protocols are light weight.

Segregated functionality into smaller separate services each with a single responsibility, Scales out by deploying each service independently, Loosely coupled, Can be written by smaller teams, Each micro services can own it's own data/database.

Monolith Architecture- Built as a single unit, deployed as single unit, Duplicated on each server ex- 3 tier apps.

From Monolith to microservices
*Break your application/systems in small units.
*Use the strangler pattern.

Microservices- Benefits
*Improved fault isolation
*Eliminate vendor or technology lock-in
*Ease of understanding
*Smaller and faster deployments
*Scalability

Microservices- Drawbacks
*Complexity is added to resolve complexity issues
  -Is your team trained, ready and has made POC's
  -Don't start with a complex infrastructure.
*Testing may appear simpler but is it?
*Deployment may appear simpler but is it?
  Hard to do with multiple teams.
  One microservices updated can impact many microservices.
*Multi databases?
*Latency issues
*Transient Errors
*Multiple point of failures.

Container- A unit of software/deployment, code/runtime/system tools system libraries

Why containers?
-Move faster by deploying smaller units
-Use fewer resources
-Fit more into the same host
-Faster automation
-Portability

VM vs Containers

Virtual Machine 
*Large footprint
*Slow to boot
*Ideal for long running tasks

Container
*Lightweight
*Quick to start
*Portable
*Ideal for short lives tasks

Docker commands like-: docker --version
                       docker ps , docker ps -a, docker run -image name, docker stop -image name, docker rmi image name,
                       docker pull, docker push, 

Rest refer to images in the folder.

Docker file {syntax}

example: FROM ngnix:alpine
         COPY ./usr/share/ngnix/html

#build
docker build -t webserver-image:v1.

#run
docekr run -d -p 8080:80 webserver-image:v1
#dicplay
curl localhost:8080

example: FROM alpine --> It's the base image 
         RUN apk add -update nodejs nodejs-npm --> install Node and NPM using package manager
         COPY ./src --> copy the files from the build context
         WORKDIR /src 
         RUN npm install -->Run a command
         EXPOSE 8080:80 -->Add a metadata
         ENTRYPOINT ["node", "./app.js"] -->what to run

Docker tag=> Create a target image
             * name:tag
                   *myimage:v1
             *repository/name:tag
                   *myacr.azurecr.io/myimage:v1

Data Persisting

Containers are ephemerous and stateless
* You usually don't store data in containers
* Non-persistent data
  *Locally on a writable layer
  *when containers are destroyed, so the data inside them

* Persistent data
  *Stored outside the container in a volume.
  *A volume is mapped to a logic folder.

Volumes
* Maps a folder on the host to a logical folder in the container.

 docker volumes command: docker create volume, docker create volume ls, docker volume inspect [volumeName], docker volume rm [volumeName],
docker volume prune

Mapping volume with container

Step-1 Crate volume
Step-2 Inspect the volume
Step-3 List the volume
Step-4 Run a container with volume
       docker run -d --name devtest -v myvol:/app ngnix:latest 

Better to mapping the local folder instead the vol
       docker run -d --name devtest -v d:/test:/app ngnix:latest
  
Inspect the container
       docker inspect devtest 

docker 

